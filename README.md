# Bare Metal Lichee RV

## 项目实现了什么？

Lichee RV 裸机编程，将自己写的裸机程序烧录至 SD 卡，实现上电启动。

实现这一步之后，就可以继续完善自己的裸机程序，写自己的 SPL，Bootloader，Kernel 等。

当然，写自己的 Bootloader 和 Kernel 或许并不一定需要依赖自己的 SPL，使用固件中通用的 OpenSBI，U-Boot 也可以做，但是让板子从头到尾都运行自己写的代码也是一件很有趣的事情。


## D1 启动流程

D1 这款 SoC 启动流程为：  

- 上电之后 `pc` 寄存器重置为 `reset vector: 0x0`，并开始加载指令执行，这个地址对应于 SoC 内置 `BROM`；  
- BROM 检查 `FEL` 引脚状态。如果用户按了 FEL 按钮，则跳转到 FEL 模块并执行，这种模式下可以使用 [xfel](https://github.com/xboot/xfel) 工具操作 Soc；  
- 否则 BROM 会：
  - 寻找启动设备；  
  - 在启动设备的特定位置，通过检查是否存在 `eGON.BT0` 来判断是否存在 `BOOT0`；  
  - 加载 `BOOT0` 到 `SRAM: 0x20000`，并对 `BOOT0` 进行完整性校验，然后执行；  
  
  如果未找到设备、未找到 BOOT0，或者校验不通过，则跳转到 FEL 模块执行；  


对于 Lichee RV 板子来说：  
- 启动设备也就是 SD 卡；  
- 可以把裸机程序作为 BOOT0；  
- 关键在于按照规范生成 BOOT0，并写到 SD 卡的指定位置；  

这样一来，Lichee RV 上电之后，就会从 SD 卡加载自己写入的 BOOT0，完成校验并执行。  

## BOOT0 规范

SD 卡上的 BOOT0 部分包括 `boot_file_head_t` 和实际的 BOOT0 代码。

```c
typedef struct __attribute__((packed)) boot_file_head
{
	u32  jump_instruction;   // one intruction jumping to real code
	u8   magic[8];           // ="eGON.BT0", not C-style string.
	u32  check_sum;          // generated by PC
	u32  length;             // generated by PC
	u32  pub_head_size;      // the size of boot_file_head_t
	u8   pub_head_vsn[4];    // the version of boot_file_head_t
	u8   file_head_vsn[4];   // the version of boot0_file_head_t or boot1_file_head_t
	u8   Boot_vsn[4];        // Boot version
	u8   eGON_vsn[4];        // eGON version
	u8   platform[8];        // platform information
} boot_file_head_t;
```

